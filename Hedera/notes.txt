java 2.3.0
js 2.4.0
go 2.4.0
swift 5.5

Wallet => Account ID, private key
		|
		v
Application / Hedera SDk => Node addresses, MirrorNode Address
			|								|
			v								v
    gRPC =>	Hedera Consensus Node			Hedera Mirror Node => gRPC(HCS pub/sub)
	
Client sending same transaction to multiple nodes
- Increases theh chance of faster consensus time
- Protecting against bad nodes

Client SDK selects best candidate node to use next by default. Spreads load across nodes and dealing with down or flapping nodes.

Multiple clients can send transactions simultaneously to the same node.
Nodes have their own throttles to prevent the chance that transactions fail after consensus due to throttles.

Browsers have rules on which hosts a page can send traffic to.
Browser clients use WebGRPC proxy to communicate with nodes.

Hedera Client
Build a client to connect to either Mainnet, testnet and previewnet.
Mirror node client is configured to the corresponding network mirror node for a predefined network.
Default mainnet mirror node connection is to the whitelisted mirror node

Creating a client:
- Prepare operator id and operator private key
- Instantiate Client object
- Set account id and key used for signing

Hedera Account
- Required to interact with hedera network services

Ways of Account Creation
- AccountCreateTransaction
- Transfer Hbar to an account 

Create a Hedera ED25519
-> Instantiate client object
-> Create a new keypair
-> Instantiate and submit a transaction
-> Query transaction to confirm that its successful
-> Get account if from the receipt

Get Account Balance
- Submit a balance query => AccountBalanceQuery clientObject

Transfer Hbar
- Create a transfer transaction
- Sum of amounts in transaction = 0

Allowance
Allow other accounts to transfer HBAR

Consensus service = Provides the ability for Hedera to provide a BFT consensus as to the order and validity of messages submitted to a topic and a consensus timestamp for those messages.

Set a submit key => Topic becomes private since each message will need to be signed by the Submit Key.
Can control who can submit messages to your topic(Enhances privacy) but data is still public as its in a public ledger.

If there's no admin key on a topic, autoRenewAccount may not be on the topic, deleteTopic isn't allowed. Only change through updateTopic is to extend expirationTime.

Create Topic:
Create txn -> sign with the client operator and submit txn to a Hedera network, request txn receipt, get topic id

CreateTransaction => new TopicCreateTransaction()

Items you can add to your topic:
Admin key = - Access control for update/deleteTopic.
- Anyone can increase topic's expiration time regardkess of the adminKey.
- If no adminKey updateTopic can only be used for topic time extension and deleteTopic is disallowed.

Submit key = - Access control for submitMessage.
- If unspecified all submissions are allowed.

Topic memo = Short public memo for giving topic info.

Auto Renew Account = - Optional account to be used at topic's expiration time to extend topic life. 
- Topic lifetime will be extended to a maximum of the autoRenewPeriod or however long it can be extended using all funds in the account(whichever is smaller and if any extension is possible with funds)

Auto Renew Period = - Initial topic lifetime and amount of time to attempt to extend the topic's lifetime automatically at topic's expiration if autoRenewAccount is configured.

Submit Message:
Subscribe message for a topic.(Sent to Consensus node)
- new TopicMessageSubmitTransaction({topicId: x, message: y})

Methods:
setTopicId(<l=topicId>), type=TopicId, required
setMessage(<message>), type=string, byte[], ByteString

Get Topic Messages:
new TopicMessageQuery().setTopicId().setStartTime().subscribe()

Methods:
setTopicId(<l=topicId>), type=TopicId, required
setStartTime(<startTime>), type=instant => Time to start subscribing to a topic's messages
setEndTime(<endTime>), type=instant
setLimit(<limit>), type=long => Number of messages to return
subscribe(<client, onNext>), type=SubscriptionHandle, required

Hedera Token service
- HTS allows devs to create custom fungible and non-fungible tokens without knowledge of smart contracts
- Customizable, fast, secure

Create Fungible Token
- Create a txn = new TokenCreateTransaction()
- Set name*, symbol*, type(nft, fungible*def), Decimal(0 for nft), InitialSupply = setTokenName("nameIdentifier").setTokenSymbol("nameShortForm").setTokenType(TokenType.FungibleCommon).setDecimals().setInitialSupply()
- Set treasuryAccountId*, account that holds initial supply = setTreasuryAccountId()
- set supplyType(finite, infinite(TokenSupplyType.Infinite))
- set supplyKey, key used for minting tokens
- freezeWith(client);
-- setAdminKey(), setKycKey(), setFreezeKey(), setWipeKey(), setPauseKey(), setFreezeDefault(), setExpirationTime(), setFeeSchedule(), setCustomFees(), setSupplyType(), setMaxSupply(), setTokenMemo(), setAutoRenewAccountId(), setAutoRenewPeriod()

Token Fee
- Fixed fee
	-- Transfers a specified amount of the token to the specified collection account each time a token transfer is initiated.
	-- Custom fee token doesn't depend on the amount of the token that's being transferred.
	-- Fee can be collected in hbar or another fungible Hedera token, nft can't be used as a type to collect the fee.
	-- Can set a custom fixed fee for both fungible and nft types.
	
- Fractional fee
	-- Transfers the specified fraction of the total value of the tokens that are being transferred to the specified fee-collecting account and is applicable to fungible tokens only.
	-- You can also impose min and max fee limits per transfer txn.
	
- Royalty fee
	-- Fractional fee that's assessed each time the ownership of an NFT is transferred from a person to another and applicable to NFTs only.
	-- Fee collector accountId defined in the royalty fee schedule will receive the fee each time.
	-- The fee charged is a fraction of the value exchanged for the NFT.
	-- If there's no value exchanged for the NFT, a fallback fee is used to charge the receiving account.

Get Token Info
- new TokenInfoQuery() -> setTokenId() -> execute(client)

Get Token Balances / info of a particular token
- new AccountBalanceQuery() -> setAccountId() -> execute(client)

Mint Fungible Tokens
- Set Token ID
- Set amount
- Sign a txn with the supply key

	- new TokenMintTransaction().setTokenId().setAmount().freezeWith(client).sign(supplyKey).execute(client)//submit txn to a hedera network

Burn Fungible Tokens = Same as mint but with new TokenBurnTransaction()

Associate Token Transaction = Allows a wallet to receive an nft or a ft
 - Set Account ID
 - Set Token IDs []
 - Sign with the private key of the account that's associated to a token

	- new TokenAssociateTransaction().setAccountId().setTokenIds([]).freezeWith().sign(accountKey).execute(client)

Transfer Fungible Tokens
- new TransferTransaction().addTokenTransfer(tokenId, fromAccountId, -amount).addTokenTransfer(tokenId, toAccountId, amount).freezeWith(client).sign(senderAccountPrivateKey).execute(client)

Freeze / Unfreeze Accounts
- new TokenFreezeTransaction().setAccountId().setTokenId().freezeWith(client).sign(tokenFreezeKey).execute(client)

Enable KYC flapping
- newTokenGrantKycTransaction().setAccountId().setTokenId().freezeWith(client).sign(tokenKycPrivateKey).execute(client)

Pause / Unpause token
-  newTokenPauseTransaction().setTokenId().freezeWith(client).sign(pauseKey).execute(client)

Wipe Tokens
- new TokenWipeTransaction().setAccountId().setTokenId().setAmount().freezeWith(client).sign(payerAccountPrivateKey).sign(tokenWipePrivateKey).execute(client)//submit txn to a hedera network

Create NFT
- Sign the txn with the treasury key
- Mint the nft
	-- NFT's use InterPlanetary File System(IPFS), a hypermedia protocol and peer to peer network for storing and sharing data and files. Doesnt require a host server like HTTP. It stores info on decentralized nodes. Created by Juan Benet. CID is an identifier for an item in IPFS.

Get NFT Info
- new TokenNftInfoQuery().setNftId(nftId).execute(client)

Transfer NFT
- new TransferTransaction().addNFTTransfer(tokenId, tokenIdSerialNumber, treasuryId, toAccountId).freezeWith(client).sign(treasuryKey).execute(client)


TRADITIONAL Application
User -> frontend -> Backend -> DB

DECENTRALIZED Application

User -> Frontend -> Backend -> DB	DB <- Backend <- Frontend <- User
  |						|					 |					   |
  |	Txn					|Subscribe/Query Data|				   Txn |
  |						v					 v					   |
  |_____________________    Hedera Network    _____________________|

dApps = Digital apps/programs that exist and run on a blockchain or p2p network of computers instead of a single computer i.e aren't in the control of a single authority.

Advantages
- No req. trusted 3rd party to operate network.
- Open and transparent, trusted
- More robust
- Users retain control of their data, ownership economy with no vendor lock in
- Attack vector is distributed so lower risk

Disadvantages
- Scalability issues, consensus algo has huge overhead
- Higher cost / txn
- Immutability